{"version":3,"sources":["components/MainGame/MainGame.tsx","components/Hangman/Hangman.tsx","components/BamTitle/BamTitle.tsx","components/Play/Play.tsx","api/getWord.ts","components/RevealedWord/RevealedWord.tsx","components/GameOver/GameOver.tsx","components/TitleScreen/TitleScreen.tsx","components/Wasted/Wasted.tsx","components/NewGameButton/NewGameButton.tsx","components/ScoreBoard/ScoreBoard.tsx","components/ResetStatsButton/ResetStatsButton.tsx","components/UsedLetters/UsedLetters.tsx","components/HealthBar/HealthBar.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["GAME_STATES","Hangman","incorrectGuessCount","containerRef","useRef","canvasRef","drawnPartsRef","previousIncorrectGuessCountRef","useState","size","setSize","hangmanParts","useMemo","bodyHeight","appendageWidth","canvasContext","lineWidth","beginPath","moveTo","lineTo","stroke","arc","Math","PI","getHangmanParts","resizeCanvas","useCallback","style","getComputedStyle","current","containerSize","parseInt","width","resizeCanvasDebounce","debounce","resetCanvas","canvas","context","getContext","clearRect","height","clearCanvas","useEffect","window","addEventListener","removeEventListener","slice","forEach","f","drawFn","className","ref","BamTitle","props","sizingRef","letters","timer","reveal","console","log","revealedLetters","state","word","length","clearInterval","setState","getBamLetters","letter","charAt","push","key","React","createRef","undefined","ceil","this","getBoundingClientRect","setInterval","opacity","replace","Component","SPACE","Play","getRevealedWord","lettersGuessed","isValid","newWord","i","char","setTimeout","solved","handleKeyDown","strikes","indexOf","prevProps","prevState","onEndGame","handleEventType","handleKeys","onKeyEvent","max","words","api","floor","random","LOCAL_STORAGE_KEY","MainGame","wins","losses","onResetStats","localStorage","setItem","onStartGame","gameState","GETTING_WORD","didWin","VICTORY","GAME_OVER","JSON","stringify","getWord","wordApi","currentWord","PLAYING","err","getDisplay","won","TITLE","data","parse","getItem","RevealedWord","toUpperCase","min","arr","j","l","marginLeft","GameOver","getMessage","NewGameButtom","TitleScreen","marginTop","getScoreBoardIfNeeded","Wasted","src","alt","memo","tabIndex","autoFocus","onClick","ScoreBoard","ResetStatsButton","ABCS","UsedLetters","map","getLetters","HealthBar","App","Boolean","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.57f20e3d.chunk.js","sourcesContent":["import React from 'react';\nimport { TitleScreen, Play, GameOver } from '../';\nimport wordApi from '../../api/getWord';\n\nconst LOCAL_STORAGE_KEY: string = 'BirdThoHangmanGameData';\n\nenum GAME_STATES {\n  TITLE = 'Title',\n  PLAYING = 'Playing',\n  GAME_OVER = 'GameOver',\n  VICTORY = 'Victory',\n  GETTING_WORD = 'GettingWord',\n}\n\ninterface MainGameState {\n  wins: number,\n  losses: number,\n  currentWord: string,\n  gameState: GAME_STATES,\n}\n\nexport class MainGame extends React.Component<{}, MainGameState> {\n  constructor(props: {}) {\n    super(props);\n\n    let wins: number;\n    let losses: number;\n    if (window.localStorage) {\n      const data = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY) || '') || {};\n      wins = data.wins;\n      losses = data.losses;\n    } else {\n      wins = 0;\n      losses = 0;\n    }\n\n    this.state = {\n      wins,\n      losses,\n      currentWord: '',\n      gameState: GAME_STATES.TITLE,\n    };\n  }\n\n  componentDidUpdate() {\n    if (this.state.gameState === GAME_STATES.GETTING_WORD) {\n      this.getWord();\n    }\n  }\n\n  onResetStats = () => {\n    localStorage.setItem(LOCAL_STORAGE_KEY, '');\n\n    this.setState({\n      wins: 0,\n      losses: 0,\n    });\n  };\n\n  onStartGame = () => {\n    this.setState({\n      gameState: GAME_STATES.GETTING_WORD,\n    });\n  };\n\n  onEndGame = (didWin: boolean) => {\n    let {\n      wins,\n      losses,\n    } = this.state;\n\n    let gameState: GAME_STATES;\n    if (didWin) {\n      ++wins;\n      gameState = GAME_STATES.VICTORY;\n    } else {\n      ++losses;\n      gameState = GAME_STATES.GAME_OVER;\n    }\n\n    localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify({\n      wins,\n      losses,\n    }));\n\n    this.setState({\n      wins, losses, gameState,\n    })\n  };\n\n  getWord = () => {\n    try {\n      const word: string | null = wordApi.getWord();\n      if (word) {\n        this.setState({\n          currentWord: word,\n          gameState: GAME_STATES.PLAYING,\n        });\n      }\n    } catch (err) {\n      console.log(err);\n    }\n  };\n\n  getDisplay = () => {\n    const {\n      onStartGame,\n      onEndGame,\n      onResetStats,\n      state: {\n        gameState,\n        currentWord,\n        wins,\n        losses,\n      },\n    } = this;\n\n    switch (gameState) {\n      case GAME_STATES.GAME_OVER:\n      case GAME_STATES.VICTORY:\n        return (<GameOver\n          won={gameState === GAME_STATES.VICTORY}\n          wins={wins} losses={losses} word={currentWord}\n          onStartGame={onStartGame} onResetStats={onResetStats}/>);\n      case GAME_STATES.PLAYING:\n        return (<Play word={currentWord} onEndGame={onEndGame}/>);\n      case GAME_STATES.GETTING_WORD:\n        return (<div>Getting word, please wait</div>);\n      case GAME_STATES.TITLE:\n      default:\n        return (<TitleScreen wins={wins} losses={losses} onResetStats={onResetStats} onStartGame={onStartGame}/>);\n    }\n  };\n\n  render () {\n    return this.getDisplay();\n  }\n}","import React, { useRef, useEffect, useMemo, useState, useCallback } from 'react';\nimport PropTypes from 'prop-types';\nimport { debounce } from 'lodash';\n\nimport './Hangman.css';\n\n/**\n * Returns an array of functions that draw each part of the Hangman on the\n * canvas, scaled according to the passed size.\n */\nconst getHangmanParts = (size: number) => {\n  const bodyHeight = size / 2;\n  const appendageWidth = bodyHeight / 3;\n\n  const platform = (canvasContext: CanvasRenderingContext2D) => {\n    canvasContext.lineWidth = 10;\n    canvasContext.beginPath();\n    canvasContext.moveTo(0, size);\n    canvasContext.lineTo(size, size);\n    canvasContext.stroke();\n  };\n\n  const post = (canvasContext: CanvasRenderingContext2D) => {\n    canvasContext.lineWidth = 10;\n    canvasContext.beginPath();\n    canvasContext.moveTo(0, 0);\n    canvasContext.lineTo(0, size);\n    canvasContext.stroke();\n  };\n\n  const pole = (canvasContext: CanvasRenderingContext2D) => {\n    canvasContext.lineWidth = 10;\n    canvasContext.beginPath();\n    canvasContext.moveTo(0, 0);\n    canvasContext.lineTo(size / 2, 0);\n    canvasContext.stroke();\n  };\n\n  const rope = (canvasContext: CanvasRenderingContext2D) => {\n    canvasContext.beginPath();\n    canvasContext.moveTo(size / 2, 0);\n    canvasContext.lineTo(size / 2, size / 10);\n    canvasContext.stroke();\n  };\n\n  const head = (canvasContext: CanvasRenderingContext2D) => {\n    canvasContext.beginPath();\n    canvasContext.arc(size / 2, size / 10 + size / 16, size / 16, 0, Math.PI * 2, true);\n    canvasContext.stroke();\n  };\n\n  const body = (canvasContext: CanvasRenderingContext2D) => {\n    canvasContext.beginPath();\n    canvasContext.moveTo(size / 2, size / 10 + size / 8);\n    canvasContext.lineTo(size / 2, size - bodyHeight);\n    canvasContext.stroke();\n  };\n\n  const leftArm = (canvasContext: CanvasRenderingContext2D) => {\n    canvasContext.beginPath();\n    canvasContext.moveTo(size / 2, size / 3);\n    canvasContext.lineTo(size / 2 - appendageWidth, size / 3);\n    canvasContext.stroke();\n  };\n\n  const rightArm = (canvasContext: CanvasRenderingContext2D) => {\n    canvasContext.beginPath();\n    canvasContext.moveTo(size / 2, size / 3);\n    canvasContext.lineTo(size / 2 + appendageWidth, size / 3);\n    canvasContext.stroke();\n  };\n\n  const leftLeg = (canvasContext: CanvasRenderingContext2D) => {\n    canvasContext.beginPath();\n    canvasContext.moveTo(size / 2, size - bodyHeight);\n    canvasContext.lineTo(size / 2 - appendageWidth, size - bodyHeight + appendageWidth);\n    canvasContext.stroke();\n  };\n\n  const rightLeg = (canvasContext: CanvasRenderingContext2D) => {\n    canvasContext.beginPath();\n    canvasContext.moveTo(size / 2, size - bodyHeight);\n    canvasContext.lineTo(size / 2 + appendageWidth, size - bodyHeight + appendageWidth);\n    canvasContext.stroke();\n  };\n\n  return [platform, post, pole, rope, head, body, leftArm, rightArm, leftLeg, rightLeg];\n};\n\n// Helper function to prepare the canvas for drawing\nconst draw = (canvasContext: CanvasRenderingContext2D,\n              drawFn: (canvasContext: CanvasRenderingContext2D) => void) => {\n  canvasContext.lineWidth = 2; // Reset line width to default\n  drawFn(canvasContext);\n};\n\n// Clears the canvas\nconst clearCanvas = (canvas: HTMLCanvasElement) => {\n  const context = canvas.getContext('2d');\n  if (context) {\n    context.clearRect(0, 0, canvas.width, canvas.height);\n  }\n};\n\ninterface HangmanProps {\n  incorrectGuessCount: number\n}\n\n/**\n * Draws the \"Hangman\" graphic with parts filled in according to the number of incorrect guesses.\n *\n * For example, to draw the first 5 parts of the hangman:\n *\n * ```javascript\n * <Hangman incorrectGuessCount={5} />\n * ```\n */\nexport const Hangman = ({ incorrectGuessCount = 0 }: HangmanProps) => {\n  const containerRef = useRef<HTMLDivElement>(null);\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const drawnPartsRef = useRef(0);\n  const previousIncorrectGuessCountRef = useRef(incorrectGuessCount);\n  const [size, setSize] = useState();\n\n  const hangmanParts = useMemo(() => getHangmanParts(size), [size]);\n\n  // Resizes the canvas based on its parent's width\n  const resizeCanvas = useCallback(() => {\n    const style = getComputedStyle(containerRef.current as Element);\n    const containerSize = parseInt(style.width);\n    setSize(containerSize);\n  }, []);\n\n  // Debounced version to use as a resize event listener\n  const resizeCanvasDebounce = useCallback(debounce(resizeCanvas, 50), []);\n\n  // Clears and resets the canvas so parts can be redrawn\n  const resetCanvas = () => {\n    if (canvasRef.current) {\n      clearCanvas(canvasRef.current);\n      drawnPartsRef.current = 0;\n    }\n  };\n\n  // Resize the canvas when the window size changes\n  useEffect(() => {\n    resizeCanvas();\n    window.addEventListener('resize', resizeCanvasDebounce);\n    return () => window.removeEventListener('resize', resizeCanvasDebounce);\n  }, [resizeCanvas, resizeCanvasDebounce]);\n\n  // Reset and redraw whenever canvas size changes\n  useEffect(resetCanvas, [size]);\n\n  // Draw the hangman parts\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) {\n      return;\n    }\n    const context = canvas.getContext('2d');\n    if (!context) return;\n\n    // If the guess count went backward then reset the drawn state\n    if (previousIncorrectGuessCountRef.current > incorrectGuessCount) {\n      resetCanvas();\n    }\n    previousIncorrectGuessCountRef.current = incorrectGuessCount;\n\n    // Draw the relevant part for the number of incorrect guesses\n    const partsToDraw = hangmanParts.slice(drawnPartsRef.current, incorrectGuessCount);\n    partsToDraw.forEach(f => draw(context, f));\n    drawnPartsRef.current = incorrectGuessCount;\n  }, [hangmanParts, incorrectGuessCount]);\n\n  return (\n    <div className=\"Hangman\" ref={containerRef}>\n      <canvas ref={canvasRef} height={size} width={size}/>\n    </div>\n  );\n};\n\nHangman.propTypes = {\n  incorrectGuessCount: PropTypes.number.isRequired,\n};\n","import React from 'react';\n\nimport './BamTitle.css';\n\ninterface BamTitleProps {\n  word: string,\n}\n\ninterface BamTitleState {\n  revealedLetters: number,\n  width: number,\n}\n\nexport class BamTitle extends React.Component<BamTitleProps, BamTitleState> {\n  sizingRef: any;\n  letters: any[];\n  timer: any;\n\n  constructor(props: BamTitleProps) {\n    super(props);\n\n    this.state = {\n      revealedLetters: 0,\n      width: 0,\n    };\n\n    this.sizingRef = React.createRef();\n    this.letters = [];\n    this.timer = undefined;\n  }\n\n  componentDidMount() {\n    console.log('Componentdidmount for bamtitle');\n    const width = Math.ceil(this.sizingRef.current.getBoundingClientRect().width) + 1;\n    this.setState({ width });\n    this.timer = setInterval(this.reveal, 600);\n  }\n\n  reveal = () => {\n    console.log('Reveal called');\n    let revealedLetters = this.state.revealedLetters;\n    ++revealedLetters;\n    if (revealedLetters === this.props.word.length) {\n      clearInterval(this.timer);\n    }\n    this.setState({\n      revealedLetters\n    });\n  };\n\n  getBamLetters = () => {\n    const {\n      props: {\n        word,\n      },\n      state: {\n        revealedLetters,\n      },\n    } = this;\n\n    if (revealedLetters === 0 || this.letters.length === revealedLetters) return this.letters;\n\n    // Save previous list of letters - Why make a new list of identical elements each time?\n    // Would be terrible form for very large words.\n    let letters = this.letters;\n    let letter = word.charAt(revealedLetters - 1);\n\n    // Need an &nbsp in unicode for the word\n    letter = letter === ' ' ? '\\u00A0' : letter;\n    letters.push(<span key={revealedLetters - 1} className={'animated'}>{letter}</span>);\n    return letters;\n  };\n\n  render () {\n    const {\n      sizingRef,\n      props: {\n        word,\n      },\n      state: {\n        width,\n      }\n    } = this;\n\n    return (<div className={'bamtitle'} style={{ width }}>\n      {width ? this.getBamLetters() : (<span ref={sizingRef} style={{ opacity: 0, }}>{word.replace(' ', '\\u00A0')}</span>)}\n    </div>);\n  }\n}\n","import React from 'react';\n\nimport KeyboardEventHandler from 'react-keyboard-event-handler';\nimport { BamTitle, Hangman, RevealedWord, Wasted, UsedLetters, HealthBar } from '../';\n\nimport './Play.css';\n\nconst SPACE = '\\u00A0';\n\ninterface PlayProps {\n  word: string,\n  onEndGame: (didWin: boolean) => void,\n}\n\nexport interface LettersGuessed {\n  [key: string]: boolean\n}\n\ninterface PlayState {\n  lettersGuessed: LettersGuessed,\n  strikes: number,\n  solved: boolean,\n}\n\nexport class Play extends React.Component<PlayProps, PlayState> {\n  constructor(props: PlayProps) {\n    super(props);\n\n    this.state = {\n      lettersGuessed: {},\n      strikes: 0,\n      solved: false,\n    };\n  }\n\n  componentDidUpdate(prevProps: PlayProps, prevState: PlayState) {\n    if (prevState.strikes === 9 && this.state.strikes === 10) {\n      // Do defeat handling here\n      setTimeout(() => {\n        this.props.onEndGame(false);\n      }, 2500);\n    } else if (!prevState.solved && this.state.solved) {\n      setTimeout(() => {\n        this.props.onEndGame(true);\n      }, 1000);\n    }\n  }\n\n  getRevealedWord = () => {\n    const {\n      props: {\n        word,\n      },\n      state: {\n        lettersGuessed,\n      }\n    } = this;\n\n    let isValid = true;\n\n    let newWord = '';\n    let length = word.length;\n\n    for (let i = 0; i < length; ++i) {\n      let char = word.charAt(i);\n      if (char !== SPACE && !lettersGuessed[char]) {\n        newWord += SPACE;\n        isValid = false;\n      } else {\n        newWord += char;\n      }\n    }\n\n    if (isValid) {\n      setTimeout(() => {\n        this.setState({\n          solved: true,\n        });\n      }, 1000);\n    }\n\n    console.log(newWord);\n\n    return newWord;\n  };\n\n  handleKeyDown = (key: string) => {\n    let {\n      props: {\n        word,\n      },\n      state: {\n        lettersGuessed,\n        strikes,\n      }\n    } = this;\n\n    if (lettersGuessed[key] || strikes === 10) {\n      return;\n    }\n\n    lettersGuessed[key] = true;\n\n    if (word.indexOf(key) === -1) {\n      ++strikes;\n    }\n\n    this.setState({\n      lettersGuessed,\n      strikes,\n    });\n  };\n\n  render () {\n    const {\n      handleKeyDown,\n      getRevealedWord,\n      state: {\n        strikes,\n        lettersGuessed,\n      }\n    } = this;\n    return (\n      <div className={'play-container'}>\n        <KeyboardEventHandler\n          handleEventType={'keydown'}\n          handleKeys={['alphabetic']}\n          onKeyEvent={handleKeyDown}/>\n        <div className={'title-container'}>\n          <BamTitle word={'HANGMAN'}/>\n        </div>\n        <HealthBar strikes={strikes} max={10}/>\n        <div className={'hang-container'}>\n          <Hangman incorrectGuessCount={strikes}/>\n          {strikes === 10 ? <Wasted/> : null}\n        </div>\n        <RevealedWord word={getRevealedWord()}/>\n        <UsedLetters lettersGuessed={lettersGuessed}/>\n        <p>Press a letter on your keyboard.</p>\n      </div>\n\n    );\n  }\n}\n","import * as data from './words_dictionary.json';\nconst words: string[] = ((data as any).default as string[]);\n\nclass WordApi {\n  words: string[];\n  length: number;\n\n  /**\n   * @param {Object} words\n   */\n  constructor(words: string[]) {\n    this.words = words;\n    this.length = this.words.length;\n  }\n\n  getWord() {\n    return this.words[Math.floor(Math.random() * this.length)];\n  }\n}\n\nconst api = new WordApi(words);\n\nexport default api;\n","import React from 'react';\n\nimport './RevealedWord.css';\n\nconst LETTER_WIDTH: number = 40;\nconst LETTER_SPACING: number = 15;\n\ninterface RevealedWordProps {\n  word: string,\n}\n\nexport const RevealedWord = (props: RevealedWordProps) => {\n  const word: string = props.word.toUpperCase();\n\n  // Limiting line length to 9 chars for fitting in 500px wide area\n  const length: number = Math.min(word.length, 9);\n  const width: number = length * LETTER_WIDTH + (length - 1) * LETTER_SPACING;\n\n  let arr: JSX.Element[] = [];\n  let j: number = 0;\n  [...word].forEach((l: string, i: number) => {\n\n    if (i > 0 && i % 9 === 0) {\n      arr.push(<br key={j++}/>);\n    }\n\n    arr.push((<div key={j++} className={'letter'} style={(i % 9 === 0) ? { marginLeft: '0px'} : {}}>\n      <span>{l}</span>\n      <div/>\n    </div>));\n  });\n\n  return (\n    <div className={'revealed'} style={{marginLeft: `calc(50% - ${width / 2}px)`, width: `${width}px`}}>\n      {arr}\n    </div>\n  );\n};","import React from 'react';\n\nimport './GameOver.css';\nimport { NewGameButtom, ResetStatsButton, ScoreBoard } from '..';\n\nconst getMessage = (won: boolean, word: string) => {\n  return (won ? ([<p>Congratulations!</p>,<p>You guessed the word:</p>, <p>{word.toUpperCase()}</p>]) :\n    ([<p>The word was:</p>, <p>{word.toUpperCase()}</p>, <p>Better luck next time!</p>]));\n};\n\ninterface Props {\n  wins: number,\n  losses: number,\n  word: string,\n  won: boolean,\n  onStartGame: () => void,\n  onResetStats: () => void,\n}\n\nexport const GameOver = ({ wins, losses, word, won, onStartGame, onResetStats }: Props) => {\n  return (\n    <div className={'gameover'}>\n      <div className={'message'}>\n        {getMessage(won, word)}\n      </div>\n      <ScoreBoard wins={wins} losses={losses}/>\n      <ResetStatsButton onResetStats={onResetStats}/>\n      <NewGameButtom onStartGame={onStartGame}/>\n    </div>\n  )\n};\n","import React from 'react';\n\nimport './TitleScreen.css';\nimport { NewGameButtom, ResetStatsButton, ScoreBoard } from '..';\n\ninterface TitleScreenProps {\n  onResetStats: () => void,\n  onStartGame: () => void,\n  wins: number,\n  losses: number,\n}\n\nconst getScoreBoardIfNeeded = ({ onResetStats, wins, losses}: TitleScreenProps) => {\n  if (wins > 0 || losses > 0) {\n    return [\n      <p>Welcome back!</p>,\n      <ScoreBoard wins={wins} losses={losses}/>,\n      <ResetStatsButton onResetStats={onResetStats}/>\n    ];\n  } else {\n    return null;\n  }\n};\n\nexport const TitleScreen = (props: TitleScreenProps) => {\n  const {\n    onStartGame,\n    wins, losses,\n  } = props;\n  return (\n    <div className={'title-window'}>\n      <div\n        className={'hang-title'}\n        /* Title page is shorter without scoreboard, so push it down a tad */\n        style={(wins || losses ? {} : {marginTop: '100px'})}\n      >\n        <span>H</span>\n        <span>A</span>\n        <span>N</span>\n        <span>G</span>\n        <span>M</span>\n        <span>A</span>\n        <span>N</span>\n        <div/>\n        <div/>\n        <div/>\n        <div/>\n        <div/>\n        <div/>\n      </div>\n      {getScoreBoardIfNeeded(props)}\n      <NewGameButtom onStartGame={onStartGame}/>\n    </div>\n  );\n};","import React from 'react';\n\nimport './Wasted.css';\n\nexport const Wasted = () => {\n  return (\n    <img className={'wasted'} src={'/wasted.png'} alt={'Wasted - you lost'}/>\n  );\n};\n","import React from 'react';\n\nimport './NewGameButton.css';\n\ninterface NewGameProps {\n  onStartGame: () => void\n}\n\nexport const NewGameButtom = React.memo(({onStartGame}: NewGameProps) =>\n  (<button\n    className={'new-game-button'}\n    tabIndex={0} autoFocus={true}\n    onClick={onStartGame}>\n    Start New Game\n  </button>));","import React from 'react';\n\nimport './ScoreBoard.css';\n\ninterface ScoreBoardProps {\n  wins: number,\n  losses: number,\n}\n\nexport const ScoreBoard = ({wins, losses}: ScoreBoardProps) => {\n  return (\n    <div className={'scoreboard'}>\n      <div className={'score'}>\n        <span>Wins</span>\n        <span>{wins}</span>\n      </div>\n      <div className={'divider'}/>\n      <div className={'score'}>\n        <span>Losses</span>\n        <span>{losses}</span>\n      </div>\n    </div>\n  );\n};","import React from 'react';\n\nimport './ResetStatsButton.css';\n\ninterface ResetStatsProps {\n  onResetStats: () => void\n}\n\nexport const ResetStatsButton = React.memo(({onResetStats}: ResetStatsProps) =>\n  (<button\n    className={'reset-stats-button'}\n    tabIndex={0} autoFocus={true}\n    onClick={onResetStats}>\n    Reset Stats\n  </button>));","import React from 'react';\n\nimport { LettersGuessed } from '..';\n\nimport './UsedLetters.css';\n\nconst ABCS: string[] = [...'abcdefghijklmnopqrstuvwxyz'];\n\nconst getLetters = (lettersGuessed: LettersGuessed) => {\n  return ABCS.map((letter, i) => {\n    return (\n      <span key={i} className={lettersGuessed[letter] ? 'crossed' : ''}>{letter}</span>\n    );\n  });\n};\n\nexport const UsedLetters = ({ lettersGuessed }: { lettersGuessed: LettersGuessed }) => {\n  return (\n    <div className={'used-letters'}>\n      {getLetters(lettersGuessed)}\n    </div>\n  );\n};\n","import React from 'react';\n\nimport './HealthBar.css';\n\ninterface HealthBarProps {\n  strikes: number,\n  max: number,\n}\n\nconst _HealthBar = (props: HealthBarProps) => {\n  const {\n    strikes,\n    max,\n  } = props;\n  return (\n    <div className={'health-bar'}>\n      <div className={'background'}/>\n      <div className={'health-juice' + (max - strikes <= 2 ? ' pulsing' : '')}\n        style={{width: `${400.0 * ((max-strikes) / max)}px`}}/>\n    </div>\n  );\n};\n\n// This component will be predictable enough to memoize\n// Although its probably not worth it.\nexport const HealthBar = React.memo(_HealthBar);\n","import React from 'react';\nimport { MainGame } from './components';\n\nimport './App.css';\n\nconst App = () => {\n  return (\n    <div className=\"App\">\n      <div className=\"container\">\n        <MainGame/>\n      </div>\n    </div>\n  );\n};\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n  // [::1] is the IPv6 localhost address.\n  window.location.hostname === '[::1]' ||\n  // 127.0.0.0/8 are considered localhost for IPv4.\n  window.location.hostname.match(\n    /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n  )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n            'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}